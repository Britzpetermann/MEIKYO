//radial blur by iq
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;
uniform sampler2D tex0;
uniform sampler2D tex1;

vec3 deform( in vec2 p )
{
    vec2 uv;

    vec2 q = vec2( sin(1.1*time+p.x),sin(1.2*time+p.y) );

    float a = atan(q.y,q.x);
    float r = sqrt(dot(q,q));

    uv.x = sin(0.0+1.0*time)+p.x*sqrt(r*r+1.0);
    uv.y = sin(0.6+1.1*time)+p.y*sqrt(r*r+1.0);

    return texture2D(tex0,uv*.5).xyz;
}

void main(void)
{
    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
    vec2 s = p;

    vec3 total = vec3(0.0);
    vec2 d = (vec2(0.0,0.0)-p)/40.0;
    float w = 1.0;
    for( int i=0; i<40; i++ )
    {
        vec3 res = deform(s);
        res = smoothstep(0.1,1.0,res*res);
        total += w*res;
        w *= .99;
        s += d;
    }
    total /= 40.0;
    float r = 1.5/(1.0+dot(p,p));
    gl_FragColor = vec4( total*r,1.0);
}

//PostPro iq

#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;

void main(void)
{
    vec2 q = gl_FragCoord.xy / resolution.xy;
    vec2 uv = 0.5 + (q-0.5)*(0.9 + 0.1*sin(0.2*time));

    vec3 oricol = texture2D(tex0,vec2(q.x,1.0-q.y)).xyz;
    vec3 col;

    col.r = texture2D(tex0,vec2(uv.x+0.003,-uv.y)).x;
    col.g = texture2D(tex0,vec2(uv.x+0.000,-uv.y)).y;
    col.b = texture2D(tex0,vec2(uv.x-0.003,-uv.y)).z;

    col = clamp(col*0.5+0.5*col*col*1.2,0.0,1.0);

    col *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);

    col *= vec3(0.8,1.0,0.7);

    col *= 0.9+0.1*sin(10.0*time+uv.y*1000.0);

    col *= 0.97+0.03*sin(110.0*time);

    float comp = smoothstep( 0.2, 0.7, sin(time) );
    col = mix( col, oricol, clamp(-2.0+2.0*q.x+3.0*comp,0.0,1.0) );

    gl_FragColor = vec4(col,1.0);
}

//MetaTunnel by TX95
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;

float h(vec3 q)
{
    float f=1.*distance(q,vec3(cos(time)+sin(time*.2),.3,2.+cos(time*.5)*.5));
    f*=distance(q,vec3(-cos(time*.7),.3,2.+sin(time*.5)));
    f*=distance(q,vec3(-sin(time*.2)*.5,sin(time),2.));
    f*=cos(q.y)*cos(q.x)-.1-cos(q.z*7.+time*7.)*cos(q.x*3.)*cos(q.y*4.)*.1;
    return f;
}

void main()
{
    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
    vec3 o=vec3(p.x,p.y*1.25-0.3,0.);
    vec3 d=vec3(p.x+cos(time)*0.3,p.y,1.)/64.;
    vec4 c=vec4(0.);
    float t=0.;
    for(int i=0;i<75;i++)
    {
        if(h(o+d*t)<.4)
        {
            t-=5.;
            for(int j=0;j<5;j++)
            {
                if(h(o+d*t)<.4)
                    break;
                t+=1.;
            }
            vec3 e=vec3(.01,.0,.0);
            vec3 n=vec3(.0);
            n.x=h(o+d*t)-h(vec3(o+d*t+e.xyy));
            n.y=h(o+d*t)-h(vec3(o+d*t+e.yxy));
            n.z=h(o+d*t)-h(vec3(o+d*t+e.yyx));
            n=normalize(n);
            c+=max(dot(vec3(.0,.0,-.5),n),.0)+max(dot(vec3(.0,-.5,.5),n),.0)*.5;
            break;
        }
        t+=5.;
    }
    gl_FragColor=c+vec4(.1,.2,.5,1.)*(t*.025);
}

//'704' by Paulo Falcao (2010)
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;

float stime=sin(time);
float ctime=cos(time);

float inObj(in vec3 p){
  float oP=length(p);
  p.x=sin(p.x)+stime;
  p.z=sin(p.z)+ctime;
  return float(min(length(p)-1.5-sin(oP-time*4.0),p.y+3.0));
}

void main(void){
  vec2 vPos=-1.0+2.0*gl_FragCoord.xy/resolution.xy;

  //Camera animation
  vec3 vuv=vec3(stime,1,0);//view up vector
  vec3 vrp=vec3(sin(time*0.7)*10.0,0,cos(time*0.9)*10.0); //view reference point
  vec3 prp=vec3(sin(time*0.7)*20.0+vrp.x+20.0,
                stime*4.0+4.0+vrp.y+3.0,
                cos(time*0.6)*20.0+vrp.z+14.0); //camera position

  //Camera setup
  vec3 vpn=normalize(vrp-prp);
  vec3 u=normalize(cross(vuv,vpn));
  vec3 v=cross(vpn,u);
  vec3 vcv=(prp+vpn);
  vec3 scrCoord=vcv+vPos.x*u*resolution.x/resolution.y+vPos.y*v;
  vec3 scp=normalize(scrCoord-prp);

  //Raymarching
  const vec3 e = vec3(0.1,0,0);
  const float maxd=200.0;

  float s=0.1;
  vec3 c,p,n;

  //speed optimization -advance ray (simple raytracing) until plane y=2.5
  float f=-(prp.y-2.5)/scp.y;
  if (f>0.0) p=prp+scp*f;
  else f=maxd;

  for(int i=0;i<256;i++){
    if (abs(s)<.01||f>maxd) break;
    f+=s;
    p=prp+scp*f;
	s=inObj(p);
  }
 
  if (f<maxd){
    if(p.y<-2.5){
      if (fract(p.x*.5)>.5)
        if (fract(p.z*.5)>.5)
          c=vec3(0,0,0);
        else
          c=vec3(1,1,1);
      else
        if (fract(p.z*.5)>.5)
          c = vec3(1,1,1);
        else
          c = vec3(0,0,0);
      n=vec3(0,1,0);
    }
    else{
      float d=length(p);
      c=vec3((sin(d*.25-time*4.0)+1.0)/2.0,
             (stime+1.0)/2.0,
             (sin(d-time*4.0)+1.0)/2.0); //color
      n=normalize(
        vec3(s-inObj(p-e.xyy),
             s-inObj(p-e.yxy),
             s-inObj(p-e.yyx)));
    }
    float b=dot(n,normalize(prp-p));
    gl_FragColor=vec4((b*c+pow(b,54.0))*(1.0-f*.005),1.0);
  }
  else gl_FragColor=vec4(0,0,0,1);
}


//'To The Road Of Ribbon' by TX95 (2008)
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;

//Object A (tunnel)
float oa(vec3 q)
{
 return cos(q.x)+cos(q.y*1.5)+cos(q.z)+cos(q.y*20.)*.05;
}

//Object B (ribbon)
float ob(vec3 q)
{
 return length(max(abs(q-vec3(cos(q.z*1.5)*.3,-.5+cos(q.z)*.2,.0))-vec3(.125,.02,time+3.),vec3(.0)));
}

//Scene
float o(vec3 q)
{
 return min(oa(q),ob(q));
}

//Get Normal
vec3 gn(vec3 q)
{
 vec3 f=vec3(.01,0,0);
 return normalize(vec3(o(q+f.xyy),o(q+f.yxy),o(q+f.yyx)));
}

//MainLoop
void main(void)
{
 vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
 p.x *= resolution.x/resolution.y;
 
 vec4 c=vec4(1.0);
 vec3 org=vec3(sin(time)*.5,cos(time*.5)*.25+.25,time),dir=normalize(vec3(p.x*1.6,p.y,1.0)),q=org,pp;
 float d=.0;

 //First raymarching
 for(int i=0;i<64;i++)
 {
  d=o(q);
  q+=d*dir;
 }
 pp=q;
 float f=length(q-org)*0.02;

 //Second raymarching (reflection)
 dir=reflect(dir,gn(q));
 q+=dir;
 for(int i=0;i<64;i++)
 {
 d=o(q);
 q+=d*dir;
 }
 c=max(dot(gn(q),vec3(.1,.1,.0)),.0)+vec4(.3,cos(time*.5)*.5+.5,sin(time*.5)*.5+.5,1.)*min(length(q-org)*.04,1.);

 //Ribbon Color
 if(oa(pp)>ob(pp))c=mix(c,vec4(cos(time*.3)*.5+.5,cos(time*.2)*.5+.5,sin(time*.3)*.5+.5,1.),.3);

 //Final Color
 vec4 fcolor = ((c+vec4(f))+(1.-min(pp.y+1.9,1.))*vec4(1.,.8,.7,1.))*min(time*.5,1.);
 gl_FragColor=vec4(fcolor.xyz,1.0);
}

//'Nautilus' by Weyland Yutani (reworked by iq) (2010)
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 resolution;
uniform vec4 mouse;

float e(vec3 c)
{
    c=cos(vec3(cos(c.r+time/6.0)*c.r-cos(c.g*3.0+time/5.0)*c.g, cos(time/4.0)*c.b/3.0*c.r-cos(time/7.0)*c.g, c.r+c.g+c.b+time));
    return dot(c*c,vec3(1.0))-1.0;
}

void main(void)
{
    vec2 c=-1.0+2.0*gl_FragCoord.rg/resolution.xy;
    vec3 o=vec3(c.r,c.g,0.0),g=vec3(c.r,c.g,1.0)/64.0,v=vec3(0.5);
    float m = 0.4;
//    float m = 1.0-1.5*mouse.x/resolution.x;

    for(int r=0;r<100;r++)
    {
      float h=e(o)-m;
      if(h<0.0)break;
      o+=h*10.0*g;
      v+=h*0.02;
    }
    // light (who needs a normal?)
    v+=e(o+0.1)*vec3(0.4,0.7,1.0);

    // ambient occlusion
    float a=0.0;
    for(int q=0;q<100;q++)
    {
       float l = e(o+0.5*vec3(cos(1.1*float(q)),cos(1.6*float(q)),cos(1.4*float(q))))-m;
       a+=clamp(4.0*l,0.0,1.0);
    }
    v*=a/100.0;
    gl_FragColor=vec4(v,1.0);
}

#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;
uniform vec4 mouse;
uniform sampler2D tex0;
uniform sampler2D tex1;

vec4 fpar00[6];
vec4 fpar01[6];


float cylinder( in vec4 sph, in vec3 ro, in vec3 rd )
{
    vec3  d = ro - sph.xyz;
    float a = dot( rd.xz, rd.xz );
    float b = dot( rd.xz, d.xz );
    float c = dot( d.xz, d.xz ) - sph.w*sph.w;
    float t;

    t = b*b - a*c;
    if( t>0.0 )
    {
        t = -(b+sqrt( t ))/a;
    }

    return t-.001;

}


float esfera( in vec4 sph, in vec3 ro, in vec3 rd )
{
    vec3  d = ro - sph.xyz;
    float b = dot( rd, d );
    float c = dot(  d, d ) - sph.w*sph.w;
    float t = b*b - c;

    if( t>0.0 )
    {
        t = -b - sqrt( t );
    }

    return t-.001;
}


bool esfera2( in vec4 sph, in vec3 ro, in vec3 rd, in float tmin )
{
    vec3  d = ro - sph.xyz;
    float b = dot( rd, d );
    float c = dot(  d, d ) - sph.w*sph.w;

    float t = b*b - c;
    bool r = false;

    if( t>0.0 )
    {
        t = -b - sqrt( t );
        r = (t>0.0) && (t<tmin);
    }

    return r;
}


bool cylinder2( in vec4 sph, in vec3 ro, in vec3 rd, in float tmin )
{
    vec3  d = ro - sph.xyz;
    float a = dot( rd.xz, rd.xz );
    float b = dot( rd.xz, d.xz );
    float c = dot( d.xz, d.xz ) - sph.w*sph.w;
    float t = b*b - a*c;
    bool r = false;
    if( t>0.0 )
    {
        t = -(b+sqrt(t));
        r = (t>0.0) && (t<(tmin*a));
    }
    return r;
}


float plane( in vec4 pla, in vec3 ro, in vec3 rd )
{
    float de = dot(pla.xyz, rd);
    de = sign(de)*max( abs(de), 0.001);
    float t = -(dot(pla.xyz, ro) + pla.w)/de;
    return t-.001;
}


vec3 calcnor( in vec4 obj, in vec4 col, in vec3 inter, out vec2 uv )
{
    vec3 nor;
    if( col.w>2.5 )
    {
        nor.xz = inter.xz - obj.xz;
        nor.y = 0.0;
        nor = nor/obj.w;
        //uv = vec2( atan(nor.x,nor.z)/3.14159, inter.y );
        uv = vec2( nor.x, inter.y );
    }
    else if( col.w>1.5 )
    {
        nor = obj.xyz;
        uv = inter.xz*.2;
    }
    else
    {
        nor = inter - obj.xyz;
        nor = nor/obj.w;
        uv = nor.xy;
    }

    return nor;
}

vec4 cmov( in vec4 a, in vec4 b, in bool cond )
{
    return cond?b:a;
}

float cmov( in float a, in float b, in bool cond )
{
    return cond?b:a;
}

int cmov( in int a, in int b, in bool cond )
{
    return cond?b:a;
}

float intersect( in vec3 ro, in vec3 rd, out vec4 obj, out vec4 col )
{
    float tmin = 10000.0;
    float t;

    col.w = -1.0;

    bool isok;

    t = esfera( fpar00[0], ro, rd );
    isok = (t>0.0) && (t<tmin);
    obj  = cmov( obj, fpar00[0], isok );
    col  = cmov( col, fpar01[0], isok );
    tmin = cmov( tmin, t, isok );

    t = esfera( fpar00[1], ro, rd );
    isok = (t>0.0) && (t<tmin);
    obj  = cmov( obj, fpar00[1], isok );
    col  = cmov( col, fpar01[1], isok );
    tmin = cmov( tmin, t, isok );

    t = cylinder( fpar00[2], ro, rd );
    isok = ( t>0.0 && t<tmin );
    obj  = cmov( obj, fpar00[2], isok );
    col  = cmov( col, fpar01[2], isok );
    tmin = cmov( tmin, t, isok );

    t = cylinder( fpar00[3], ro, rd );
    isok = ( t>0.0 && t<tmin );
    obj  = cmov( obj, fpar00[3], isok );
    col  = cmov( col, fpar01[3], isok );
    tmin = cmov( tmin, t, isok );

    t = plane( fpar00[4], ro, rd );
    isok = ( t>0.0 && t<tmin );
    obj  = cmov( obj, fpar00[4], isok );
    col  = cmov( col, fpar01[4], isok );
    tmin = cmov( tmin, t, isok );

    t = plane( fpar00[5], ro, rd );
    isok = ( t>0.0 && t<tmin );
    obj  = cmov( obj, fpar00[5], isok );
    col  = cmov( col, fpar01[5], isok );
    tmin = cmov( tmin, t, isok );

    return tmin;
}






bool intersectShadow( in vec3 ro, in vec3 rd, in float l )
{
    float t;

    bvec4 sss;

    sss.x = esfera2(   fpar00[0], ro, rd, l );
    sss.y = esfera2(   fpar00[1], ro, rd, l );
    sss.z = cylinder2( fpar00[2], ro, rd, l );
    sss.w = cylinder2( fpar00[3], ro, rd, l );

    return any(sss);
}


vec4 basicShade( in vec3 inter, in vec4 obj, in vec4 col, in vec3 rd, in vec4 luz, out vec4 ref )
{
    vec3 nor;
    float dif, spe;
    vec2 uv;


    nor = calcnor( obj, col, inter, uv );


    dif = dot( nor, luz.xyz );
    ref.xyz = reflect( rd, nor );
    spe = dot( ref.xyz, luz.xyz );
    spe = max( spe, 0.0 );
    spe = spe*spe;
    spe = spe*spe;

    if( intersectShadow( inter, luz.xyz, luz.w ) )
    {
        dif = 0.0;
    }


    col *= texture2D( tex0, uv );

    // amb + dif + spec
    dif = max(dif,0.0);
    col = col*( vec4(.3,.34,.38,1) + .5*vec4(1.0,0.95,0.8,1.0)*dif ) + .5*spe;

    // fresnel
    dif = dot( nor, -rd );
    ref.w = dif;
    dif = 1.0 - dif*dif;
    dif = dif*dif;
    col = col + .35*vec4( dif );

    return( col );
}

// 'Kinderpainter' by iq (2006)

void main( void )
{
    vec4  luz;
    vec4  obj, col;
    vec3  nor;
    vec4  ref;

    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
    p *= vec2(resolution.x/resolution.y,1.0);

    fpar00[0] = vec4( 1.2*sin( 6.2831*.33*time + 0.0 ), 0.0,  1.8*sin( 6.2831*.39*time + 1.0 ), 1 );
    fpar00[1] = vec4( 1.5*sin( 6.2831*.31*time + 4.0 ), 1.0*sin( 6.2831*.29*time + 1.9),  1.8*sin( 6.2831*.29*time + 0.0 ), 1 );
    fpar00[2] = vec4( -1.2, 0.0, -0.0, 0.4 );
    fpar00[3] = vec4(  1.2, 0.0, -0.0, 0.4 );
    fpar00[4] = vec4(  0.0, 1.0, 0.0, 2.0 );
    fpar00[5] = vec4(  0.0, -1.0, 0.0, 2.0 );

    fpar01[0] = vec4( 0.9, 0.8, 0.6, 1.0 );
    fpar01[1] = vec4( 1.0, 0.6, 0.4, 1.0 );
    fpar01[2] = vec4( 0.8, 0.6, 0.5, 3.0 );
    fpar01[3] = vec4( 0.5, 0.5, 0.7, 3.0 );
    fpar01[4] = vec4( 1.0, 0.9, 0.9, 2.0 );
    fpar01[5] = vec4( 1.0, 0.9, 0.9, 2.0 );

    float an = .15*time - 6.2831*mouse.x/resolution.x;
    float di = 2.0+3.0*mouse.y/resolution.y;
    vec2 sc = vec2(cos(an),sin(an));
    vec3 rd = normalize(vec3(p.x*sc.x-sc.y,p.y,sc.x+p.x*sc.y));
    vec3 ro = vec3(di*sc.y,0.0,-di*sc.x);

    float tmin = intersect( ro, rd, obj, col );

    vec3 inter = ro + rd*tmin;

    luz.xyz = vec3(0.0,1.5,-3.0)-inter;
    luz.w = length( luz.xyz );
    luz.xyz = luz.xyz/luz.w;

    col = basicShade( inter, obj, col, rd, luz, ref );

    vec4 col2;
    vec4 ref2;
    tmin = intersect( inter, ref.xyz, obj, col2 );
    inter = inter + ref.xyz*tmin;
    luz.xyz = vec3(0.0,1.5,-1.0)-inter;
    luz.w = length( luz.xyz );
    luz.xyz = luz.xyz/luz.w;
    col2 = basicShade( inter, obj, col2, ref.xyz, luz, ref2 );

    col = mix( col, col2, .5-.5*ref.w );

    gl_FragColor = col;
}

//'Metatunnel' by TX95 (2009)

#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;

float h(vec3 q)
{
    float f=1.*distance(q,vec3(cos(time)+sin(time*.2),.3,2.+cos(time*.5)*.5));
    f*=distance(q,vec3(-cos(time*.7),.3,2.+sin(time*.5)));
    f*=distance(q,vec3(-sin(time*.2)*.5,sin(time),2.));
    f*=cos(q.y)*cos(q.x)-.1-cos(q.z*7.+time*7.)*cos(q.x*3.)*cos(q.y*4.)*.1;
    return f;
}

void main()
{
    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
    vec3 o=vec3(p.x,p.y*1.25-0.3,0.);
    vec3 d=vec3(p.x+cos(time)*0.3,p.y,1.)/64.;
    vec4 c=vec4(0.);
    float t=0.;
    for(int i=0;i<75;i++)
    {
        if(h(o+d*t)<.4)
        {
            t-=5.;
            for(int j=0;j<5;j++)
            {
                if(h(o+d*t)<.4)
                    break;
                t+=1.;
            }
            vec3 e=vec3(.01,.0,.0);
            vec3 n=vec3(.0);
            n.x=h(o+d*t)-h(vec3(o+d*t+e.xyy));
            n.y=h(o+d*t)-h(vec3(o+d*t+e.yxy));
            n.z=h(o+d*t)-h(vec3(o+d*t+e.yyx));
            n=normalize(n);
            c+=max(dot(vec3(.0,.0,-.5),n),.0)+max(dot(vec3(.0,-.5,.5),n),.0)*.5;
            break;
        }
        t+=5.;
    }
    gl_FragColor=c+vec4(.1,.2,.5,1.)*(t*.025);
}

//julia
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;

void main(void)
{
    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
    vec2 cc = vec2( cos(.25*time), sin(.25*time*1.423) );

    float dmin = 1000.0;
    vec2 z  = p*vec2(1.33,1.0);
    for( int i=0; i<64; i++ )
    {
        z = cc + vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y );
        float m2 = dot(z,z);
        if( m2>100.0 ) break;
        dmin=min(dmin,m2);
        }

    float color = sqrt(sqrt(dmin))*0.7;
    gl_FragColor = vec4(color,color,color,1.0);
}

//plasma

#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;

void main(void)
{
   float x = gl_FragCoord.x;
   float y = gl_FragCoord.y;
   float mov0 = x+y+cos(sin(time)*2.)*100.+sin(x/100.)*1000.;
   float mov1 = y / resolution.y / 0.2 + time;
   float mov2 = x / resolution.x / 0.2;
   float c1 = abs(sin(mov1+time)/2.+mov2/2.-mov1-mov2+time);
   float c2 = abs(sin(c1+sin(mov0/1000.+time)+sin(y/40.+time)+sin((x+y)/100.)*3.));
   float c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));
   gl_FragColor = vec4( c1,c2,c3,1.0);
}
`